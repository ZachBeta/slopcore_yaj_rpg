<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Debugger</title>
    <script type="module">
        // Import Three.js as ES module to avoid deprecation warnings
        import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
        window.THREE = THREE; // Make it globally available for our script
    </script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background-color: #222;
            color: #fff;
        }
        #debug-container {
            display: flex;
            height: 100vh;
        }
        #scene-container {
            flex: 3;
        }
        #debug-panel {
            flex: 1;
            padding: 10px;
            background-color: #333;
            overflow-y: auto;
            max-width: 300px;
        }
        #debug-info {
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .control-group {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
        }
        button {
            padding: 8px;
            margin: 5px 0;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        input {
            width: 40px;
            padding: 4px;
            margin: 0 5px;
        }
        .position-control {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .position-label {
            width: 15px;
            display: inline-block;
        }
        .player-list {
            margin-top: 10px;
        }
        .player-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .player-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid #fff;
        }
    </style>
</head>
<body>
    <div id="debug-container">
        <div id="scene-container"></div>
        <div id="debug-panel">
            <h3>Multiplayer Debugger</h3>
            
            <div class="control-group">
                <h4>Connection</h4>
                <div id="connection-status">Not connected</div>
                <button id="connect-btn">Connect to Server</button>
                <button id="disconnect-btn">Disconnect</button>
            </div>
            
            <div class="control-group">
                <h4>Position</h4>
                <div class="position-control">
                    <span class="position-label">X:</span>
                    <input type="number" id="pos-x" value="0" step="1">
                    <span class="position-label">Y:</span>
                    <input type="number" id="pos-y" value="0" step="1">
                    <span class="position-label">Z:</span>
                    <input type="number" id="pos-z" value="0" step="1">
                </div>
                <button id="update-pos-btn">Send Position Update</button>
                <button id="random-pos-btn">Random Position</button>
            </div>
            
            <div class="control-group">
                <h4>Debug</h4>
                <button id="request-debug-btn">Request Debug State</button>
                <button id="clear-log-btn">Clear Log</button>
            </div>
            
            <div class="control-group">
                <h4>Players</h4>
                <div id="player-list" class="player-list"></div>
            </div>
            
            <h4>Debug Info</h4>
            <div id="debug-info"></div>
        </div>
    </div>

    <script type="module">
        // Use the globally available THREE from the import above
        const THREE = window.THREE;
        
        // Import game events
        import { GameEvent } from '/src/constants.js';
        
        // Debug state
        const debugState = {
            localPlayerId: '',
            serverUrl: window.location.hostname === 'localhost' ? 
                       'http://localhost:8080' : 
                       `${window.location.protocol}//${window.location.hostname}`,
            connected: false,
            players: new Map(),
            diagnostics: null,
            logs: []
        };

        // DOM elements
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const updatePosBtn = document.getElementById('update-pos-btn');
        const randomPosBtn = document.getElementById('random-pos-btn');
        const requestDebugBtn = document.getElementById('request-debug-btn');
        const clearLogBtn = document.getElementById('clear-log-btn');
        const connectionStatus = document.getElementById('connection-status');
        const posXInput = document.getElementById('pos-x');
        const posYInput = document.getElementById('pos-y');
        const posZInput = document.getElementById('pos-z');
        const playerListEl = document.getElementById('player-list');
        const debugInfoEl = document.getElementById('debug-info');
        const sceneContainer = document.getElementById('scene-container');

        // THREE.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
        sceneContainer.appendChild(renderer.domElement);

        // Setup scene
        scene.background = new THREE.Color(0x222222);
        
        // Add grid for reference
        const gridHelper = new THREE.GridHelper(100, 100);
        scene.add(gridHelper);
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        // Add directional light
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);
        
        // Camera position
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        // Controls to orbit the camera
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const cameraDistance = camera.position.length();
        
        sceneContainer.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            // Rotate the camera around the center
            const rotationSpeed = 0.01;
            
            // Calculate new camera position
            const theta = -deltaX * rotationSpeed;
            const phi = deltaY * rotationSpeed;
            
            const currentPosition = new THREE.Vector3().copy(camera.position);
            
            // Rotate horizontally
            currentPosition.x = currentPosition.x * Math.cos(theta) - currentPosition.z * Math.sin(theta);
            currentPosition.z = currentPosition.x * Math.sin(theta) + currentPosition.z * Math.cos(theta);
            
            // Limit vertical rotation
            const verticalAngle = Math.atan2(
                Math.sqrt(currentPosition.x * currentPosition.x + currentPosition.z * currentPosition.z),
                currentPosition.y
            );
            
            const newVerticalAngle = Math.max(0.1, Math.min(Math.PI - 0.1, verticalAngle + phi));
            const horizontalLength = Math.sin(newVerticalAngle) * cameraDistance;
            const normalizedHorizontal = new THREE.Vector2(currentPosition.x, currentPosition.z).normalize();
            
            camera.position.x = normalizedHorizontal.x * horizontalLength;
            camera.position.y = Math.cos(newVerticalAngle) * cameraDistance;
            camera.position.z = normalizedHorizontal.y * horizontalLength;
            
            camera.lookAt(0, 0, 0);
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        // Allow zooming with mouse wheel
        sceneContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const direction = e.deltaY > 0 ? 1 : -1;
            
            const currentDistance = camera.position.length();
            const newDistance = Math.max(5, Math.min(100, currentDistance * (1 + direction * zoomSpeed)));
            const ratio = newDistance / currentDistance;
            
            camera.position.multiplyScalar(ratio);
            camera.lookAt(0, 0, 0);
        });

        // Socket.io
        let socket = null;

        // Connect to the server
        function connect() {
            if (socket) {
                log('Already connected, disconnecting first...');
                socket.disconnect();
            }
            
            log(`Connecting to server at ${debugState.serverUrl}`);
            socket = io(debugState.serverUrl);
            
            // Set up event listeners
            socket.on('connect', () => {
                debugState.connected = true;
                debugState.localPlayerId = socket.id || '';
                updateConnectionStatus();
                log(`Connected with ID: ${debugState.localPlayerId}`);
                
                // Join as a player
                socket.emit('player_join', {});
            });
            
            socket.on('disconnect', () => {
                debugState.connected = false;
                updateConnectionStatus();
                log('Disconnected from server');
                
                // Clear all players from the scene
                clearPlayers();
            });
            
            socket.on('player_joined', (data) => {
                log(`Player joined: ${data.id}`);
                addOrUpdatePlayer(data);
            });
            
            socket.on('players_list', (players) => {
                log(`Received players list with ${players.length} players`);
                players.forEach(addOrUpdatePlayer);
            });
            
            socket.on('player_moved', (data) => {
                addOrUpdatePlayer(data);
            });
            
            socket.on('player_left', (playerId) => {
                log(`Player left: ${playerId}`);
                removePlayer(playerId);
            });
            
            socket.on('server_diagnostics', (data) => {
                debugState.diagnostics = data;
                updateDebugInfo();
            });
            
            socket.on('debug_state', (data) => {
                log('Received debug state:', data);
                updateDebugInfo();
            });
            
            socket.on('force_state_correction', (data) => {
                log('Received state correction:', {
                    position: data.position,
                    color: data.color
                });
                
                // Update position inputs to match server's position
                if (data.position) {
                    posXInput.value = data.position.x;
                    posYInput.value = data.position.y;
                    posZInput.value = data.position.z;
                }
                
                // Update local player
                addOrUpdatePlayer({
                    id: debugState.localPlayerId,
                    position: data.position,
                    color: data.color
                });
            });
        }

        // Disconnect from the server
        function disconnect() {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
        }

        // Send position update
        function sendPositionUpdate() {
            if (!socket || !debugState.connected) {
                log('Not connected to server');
                return;
            }
            
            const position = {
                x: parseFloat(posXInput.value),
                y: parseFloat(posYInput.value),
                z: parseFloat(posZInput.value)
            };
            
            const rotation = { x: 0, y: 0, z: 0 };
            
            log(`Sending position update: ${JSON.stringify(position)}`);
            socket.emit(GameEvent.POSITION_UPDATE, { position, rotation });
            
            // Update local player representation
            const localPlayer = debugState.players.get(debugState.localPlayerId);
            if (localPlayer) {
                localPlayer.mesh.position.set(position.x, position.y, position.z);
            }
        }
        
        // Send random position update
        function sendRandomPosition() {
            if (!socket || !debugState.connected) {
                log('Not connected to server');
                return;
            }
            
            const x = Math.floor(Math.random() * 40) - 20;
            const y = 1;
            const z = Math.floor(Math.random() * 40) - 20;
            
            posXInput.value = x;
            posYInput.value = y;
            posZInput.value = z;
            
            const position = { x, y, z };
            const rotation = { x: 0, y: 0, z: 0 };
            
            log(`Sending random position: ${JSON.stringify(position)}`);
            socket.emit(GameEvent.POSITION_UPDATE, { position, rotation });
            
            // Update local player representation
            const localPlayer = debugState.players.get(debugState.localPlayerId);
            if (localPlayer) {
                localPlayer.mesh.position.set(x, y, z);
            }
        }

        // Request debug state
        function requestDebugState() {
            if (!socket || !debugState.connected) {
                log('Not connected to server');
                return;
            }
            
            log('Requesting debug state');
            socket.emit('request_debug_state');
        }

        // Add or update a player in the scene
        function addOrUpdatePlayer(data) {
            const { id, position, color } = data;
            
            // Skip if no position or color
            if (!position || !color) {
                log(`Invalid player data for ${id}`);
                return;
            }
            
            let playerObj = debugState.players.get(id);
            
            if (!playerObj) {
                // Create new player object
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color(color.r, color.g, color.b)
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Add name label
                const isLocalPlayer = id === debugState.localPlayerId;
                if (isLocalPlayer) {
                    // Add directional arrow for local player
                    const arrowGeometry = new THREE.ConeGeometry(0.3, 1, 8);
                    const arrowMaterial = new THREE.MeshLambertMaterial({
                        color: 0xFFFFFF
                    });
                    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                    arrow.position.set(0, 1, 0);
                    arrow.rotation.x = -Math.PI / 2;
                    mesh.add(arrow);
                    
                    // Add circle under local player
                    const circleGeometry = new THREE.CircleGeometry(0.7, 16);
                    const circleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFFF00,
                        side: THREE.DoubleSide
                    });
                    const circle = new THREE.Mesh(circleGeometry, circleMaterial);
                    circle.rotation.x = Math.PI / 2;
                    circle.position.set(0, -0.5, 0);
                    mesh.add(circle);
                }
                
                playerObj = { id, mesh, color };
                scene.add(mesh);
                debugState.players.set(id, playerObj);
                
                log(`Created new player mesh for ${id}`);
            } else {
                // Update material color if it changed
                if (color) {
                    playerObj.mesh.material.color.setRGB(color.r, color.g, color.b);
                    playerObj.color = color;
                }
            }
            
            // Update position
            if (position) {
                playerObj.mesh.position.set(position.x, position.y, position.z);
            }
            
            // Update player list display
            updatePlayerList();
        }

        // Remove a player from the scene
        function removePlayer(id) {
            const playerObj = debugState.players.get(id);
            if (playerObj) {
                scene.remove(playerObj.mesh);
                debugState.players.delete(id);
                updatePlayerList();
            }
        }

        // Clear all players from the scene
        function clearPlayers() {
            for (const [id, playerObj] of debugState.players.entries()) {
                scene.remove(playerObj.mesh);
            }
            debugState.players.clear();
            updatePlayerList();
        }

        // Update the connection status display
        function updateConnectionStatus() {
            connectionStatus.textContent = debugState.connected ? 
                `Connected (ID: ${debugState.localPlayerId})` : 
                'Not connected';
            
            connectionStatus.style.color = debugState.connected ? '#4CAF50' : '#f44336';
        }

        // Update the player list display
        function updatePlayerList() {
            playerListEl.innerHTML = '';
            
            for (const [id, playerObj] of debugState.players.entries()) {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'player-color';
                colorSwatch.style.backgroundColor = `rgb(${playerObj.color.r * 255}, ${playerObj.color.g * 255}, ${playerObj.color.b * 255})`;
                
                const playerId = document.createElement('span');
                playerId.textContent = id === debugState.localPlayerId ? `${id} (you)` : id.substring(0, 6);
                
                playerItem.appendChild(colorSwatch);
                playerItem.appendChild(playerId);
                playerListEl.appendChild(playerItem);
            }
        }

        // Add a log message
        function log(message, data) {
            const timestamp = new Date().toISOString().split('T')[1].substring(0, 8);
            let logMessage = `[${timestamp}] ${message}`;
            
            if (data) {
                logMessage += ` ${JSON.stringify(data)}`;
            }
            
            console.log(logMessage);
            debugState.logs.push(logMessage);
            
            // Keep log size reasonable
            if (debugState.logs.length > 100) {
                debugState.logs.shift();
            }
            
            updateDebugInfo();
        }

        // Clear log messages
        function clearLog() {
            debugState.logs = [];
            updateDebugInfo();
        }

        // Update the debug info display
        function updateDebugInfo() {
            let info = `Server: ${debugState.serverUrl}\n`;
            info += `Connected: ${debugState.connected}\n`;
            info += `Local ID: ${debugState.localPlayerId}\n`;
            info += `Players: ${debugState.players.size}\n\n`;
            
            if (debugState.diagnostics) {
                info += `Uptime: ${debugState.diagnostics.uptime}s\n`;
                info += `Server FPS: ${debugState.diagnostics.fps}\n`;
                info += `Player Count: ${debugState.diagnostics.playerCount}\n`;
                info += `Connections: ${debugState.diagnostics.connections}\n\n`;
            }
            
            info += '--- Logs ---\n';
            info += debugState.logs.join('\n');
            
            debugInfoEl.textContent = info;
            
            // Auto-scroll to bottom
            debugInfoEl.scrollTop = debugInfoEl.scrollHeight;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
        });

        // Event listeners
        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        updatePosBtn.addEventListener('click', sendPositionUpdate);
        randomPosBtn.addEventListener('click', sendRandomPosition);
        requestDebugBtn.addEventListener('click', requestDebugState);
        clearLogBtn.addEventListener('click', clearLog);

        // Start animation loop
        animate();
        
        // Initial update
        updateConnectionStatus();
        updateDebugInfo();
    </script>
</body>
</html> 